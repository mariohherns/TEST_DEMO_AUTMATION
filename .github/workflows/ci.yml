name: CI

"on":
  push:
    branches: ["main"]
  pull_request:

jobs:
  backend_tests:
    name: Backend | Integration + System (SIT) | pytest
    runs-on: ubuntu-latest

    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: app
          POSTGRES_PASSWORD: app
          POSTGRES_DB: refinery
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U app -d refinery"
          --health-interval 5s
          --health-timeout 5s
          --health-retries 20

    env:
      APP_ENV: ci
      DATABASE_URL: postgresql+psycopg://app:app@localhost:5432/refinery
      JWT_SECRET: ci_secret
      JWT_EXPIRE_MIN: "120"
      CORS_ORIGINS: http://localhost:3000
      API_BASE: http://127.0.0.1:8000

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"

      - name: Install backend deps
        working-directory: backend
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install fastapi uvicorn
          pip install pytest httpx pytest-html

      - name: Start FastAPI (background) + wait
        working-directory: backend
        run: |
          nohup python -m uvicorn app.main:app --host 0.0.0.0 --port 8000 > uvicorn.log 2>&1 &
          echo "Waiting for backend..."
          for i in {1..60}; do
            if curl -sSf http://127.0.0.1:8000/docs >/dev/null 2>&1; then
              echo "Backend up!"
              break
            fi
            sleep 1
          done
          if ! curl -sSf http://127.0.0.1:8000/docs >/dev/null 2>&1; then
            echo "Backend did not start. Last 200 lines:"
            tail -n 200 uvicorn.log || true
            exit 1
          fi

      - name: Run backend tests (JUnit + HTML report)
        working-directory: backend
        run: |
          mkdir -p test-results backend/artifacts
          pytest -q app/tests \
            --junitxml=test-results/backend-junit.xml \
            --html=artifacts/backend_report.html --self-contained-html

      - name: Upload backend artifacts (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: backend-artifacts
          path: |
            backend/uvicorn.log
            backend/test-results
            backend/artifacts

  ui_jest:
    name: UI | Unit + Integration Tests | Jest
    runs-on: ubuntu-latest
    needs: [backend_tests]

    env:
      NEXT_PUBLIC_API_BASE: http://127.0.0.1:8000
      JEST_JUNIT_OUTPUT_DIR: test-results
      JEST_JUNIT_OUTPUT_NAME: jest-junit.xml

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install UI deps
        working-directory: ui
        run: |
          npm ci || npm install

      - name: Run Jest (JUnit report)
        working-directory: ui
        run: |
          mkdir -p test-results
          npm test -- \
            --ci \
            --verbose \
            --reporters=default \
            --reporters=jest-junit

      - name: Upload Jest artifacts (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ui-jest-artifacts
          path: ui/test-results

  ui_smoke:
    name: UI | E2E Smoke Tests | Playwright (pytest)
    runs-on: ubuntu-latest
    needs: [backend_tests]

    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: app
          POSTGRES_PASSWORD: app
          POSTGRES_DB: refinery
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U app -d refinery"
          --health-interval 5s
          --health-timeout 5s
          --health-retries 20

    env:
      APP_ENV: ci
      DATABASE_URL: postgresql+psycopg://app:app@localhost:5432/refinery
      JWT_SECRET: ci_secret
      JWT_EXPIRE_MIN: "120"
      CORS_ORIGINS: http://localhost:3000,http://127.0.0.1:3000
      BASE_URL: http://127.0.0.1:3000
      NEXT_PUBLIC_API_BASE: http://127.0.0.1:8000
      API_BASE: http://127.0.0.1:8000

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          cache: "pip"

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"
          cache-dependency-path: ui/package-lock.json

      - name: Install backend + UI test deps (Playwright)
        run: |
          python -m pip install --upgrade pip
          pip install -r backend/requirements.txt
          pip install pytest pytest-html playwright pytest-playwright

      - name: Install Playwright browsers
        run: |
          python -m playwright install --with-deps chromium

      - name: Start FastAPI (background) + wait
        working-directory: backend
        run: |
          nohup python -m uvicorn app.main:app --host 0.0.0.0 --port 8000 > uvicorn.log 2>&1 &
          echo "Waiting for backend..."
          for i in {1..30}; do
            if curl -sSf http://127.0.0.1:8000/docs >/dev/null 2>&1; then
              echo "Backend up!"
              break
            fi
            sleep 1
          done
          if ! curl -sSf http://127.0.0.1:8000/docs >/dev/null 2>&1; then
            echo "Backend did not start. Last 200 lines:"
            tail -n 200 uvicorn.log || true
            exit 1
          fi

      - name: Install UI deps (cached)
        working-directory: ui
        run: npm ci

      - name: Build UI
        working-directory: ui
        env:
          NEXT_PUBLIC_API_BASE: http://127.0.0.1:8000
        run: npm run build

      - name: Start UI (background) + wait
        working-directory: ui
        env:
          NEXT_PUBLIC_API_BASE: http://127.0.0.1:8000
        run: |
          nohup npm run start -- -p 3000 > next.log 2>&1 &
          echo "Waiting for UI..."
          for i in {1..30}; do
            if curl -sSf http://127.0.0.1:3000/login >/dev/null 2>&1; then
              echo "UI up!"
              break
            fi
            sleep 1
          done
          if ! curl -sSf http://127.0.0.1:3000/login >/dev/null 2>&1; then
            echo "UI did not start. Last 200 lines:"
            tail -n 200 next.log || true
            exit 1
          fi

      - name: UI sanity check
        run: |
          curl -sSf http://127.0.0.1:3000/login | head -n 20

      - name: Run Playwright UI tests (JUnit + HTML report)
        run: |
          mkdir -p ui_tests/artifacts ui_tests/test-results
          pytest -q ui_tests/e2e/smoke \
            --junitxml=ui_tests/test-results/ui-e2e-junit.xml \
            --html=ui_tests/artifacts/ui_report.html --self-contained-html

      - name: Upload UI artifacts (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ui-e2e-artifacts
          path: |
            ui_tests/artifacts
            ui_tests/test-results
            ui_tests/artifacts
            backend/uvicorn.log
            ui/next.log
            test-results

  jira_defects:
    name: JIRA | Create defect + attach reports
    runs-on: ubuntu-latest
    needs: [backend_tests, ui_jest, ui_smoke]
    if: always()

    steps:
      - name: Gate (only create on failures)
        id: gate
        run: |
          if [[ "${{ needs.backend_tests.result }}" == "success" && \
                "${{ needs.ui_jest.result }}" == "success" && \
                "${{ needs.ui_smoke.result }}" == "success" ]]; then
            echo "create=false" >> $GITHUB_OUTPUT
          else
            echo "create=true" >> $GITHUB_OUTPUT
          fi

      - name: Download all artifacts
        if: steps.gate.outputs.create == 'true'
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Install xml utils
        if: steps.gate.outputs.create == 'true'
        run: |
          sudo apt-get update
          sudo apt-get install -y xmlstarlet zip

      - name: Summarize failures (JUnit)
        if: steps.gate.outputs.create == 'true'
        id: summary
        run: |
          set -e
          mapfile -t files < <(find artifacts -type f -name "*.xml" | grep -E "junit|jest-junit|e2e|backend" || true)

          out=""
          for f in "${files[@]}"; do
            fails=$(xmlstarlet sel -t -v "sum(//testsuite/@failures) + sum(//testsuite/@errors)" "$f" 2>/dev/null || echo "0")
            if [[ "$fails" != "0" ]]; then
              out+="\n### Failures in: $f (count=$fails)\n"
              out+=$(xmlstarlet sel -t -m "//testcase[failure or error]" -v "concat(@classname,'::',@name)" -n "$f" 2>/dev/null | head -n 40 | sed 's/^/- /')
              out+="\n"
            fi
          done

          if [[ -z "$out" ]]; then
            out="Artifacts downloaded but no failing testcases were found in JUnit XML."
          fi

          echo "text<<EOF" >> $GITHUB_OUTPUT
          echo -e "$out" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Package reports to attach
        if: steps.gate.outputs.create == 'true'
        id: pkg
        run: |
          set -e
          mkdir -p jira-attachments

          find artifacts -type f \( \
            -name "*.html" -o \
            -name "*.xml" -o \
            -name "*.log" \
          \) -print | head -n 200 > files.txt || true

          while IFS= read -r f; do
            dest="jira-attachments/${f#artifacts/}"
            mkdir -p "$(dirname "$dest")"
            cp "$f" "$dest" || true
          done < files.txt

          zip -r jira-attachments.zip jira-attachments >/dev/null
          echo "zip=jira-attachments.zip" >> $GITHUB_OUTPUT

      - name: Create/Update JIRA issue (main only)
        if: steps.gate.outputs.create == 'true' && github.ref == 'refs/heads/main'
        id: jira
        env:
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_PROJECT_KEY: ${{ secrets.JIRA_PROJECT_KEY }}
          JIRA_ISSUE_TYPE: ${{ secrets.JIRA_ISSUE_TYPE }}
          COMMIT_SHA: ${{ github.sha }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          SUMMARY_TEXT: ${{ steps.summary.outputs.text }}
        run: |
          set -euo pipefail

          # sanitize Jira base url (remove hidden CRLF/newlines + trailing slash)
          JIRA_BASE_URL="$(printf "%s" "$JIRA_BASE_URL" | tr -d '\r\n' | sed 's:/*$::')"

          label="gha-${COMMIT_SHA}"

          # Safe search using urlencoded jql (avoids curl URL malformed errors)
          resp=$(mktemp)
          code=$(curl -sS -o "$resp" -w "%{http_code}" \
            -u "${JIRA_EMAIL}:${JIRA_API_TOKEN}" \
            -H "Accept: application/json" \
            -G \
            --data-urlencode "jql=project=${JIRA_PROJECT_KEY} AND labels=${label} ORDER BY created DESC" \
            "${JIRA_BASE_URL}/rest/api/3/search")

          if [[ "$code" -ge 400 ]]; then
            echo "Jira search failed HTTP $code"
            cat "$resp"
            exit 1
          fi

          existing_key=$(python3 - "$resp" <<'PY'
          import json,sys
          data=json.load(open(sys.argv[1]))
          issues=data.get("issues",[])
          print(issues[0]["key"] if issues else "")
          PY
          )

          desc=$(python3 - <<'PY'
          import os
          print(f"""CI run: {os.environ['RUN_URL']}
          Commit: {os.environ['COMMIT_SHA']}

          Failures summary:
          {os.environ.get('SUMMARY_TEXT','')}
          """)
          PY
          )
          export DESC="$desc"

          if [[ -n "$existing_key" ]]; then
            issue="$existing_key"
            echo "Updating existing issue: $issue"

            payload=$(python3 - <<'PY'
          import json, os
          body=os.environ["DESC"]
          print(json.dumps({
            "body":{
              "type":"doc","version":1,
              "content":[{"type":"paragraph","content":[{"type":"text","text":body}]}]
            }
          }))
          PY
          )

            resp2=$(mktemp)
            code2=$(curl -sS -o "$resp2" -w "%{http_code}" -X POST \
              -u "${JIRA_EMAIL}:${JIRA_API_TOKEN}" \
              -H "Accept: application/json" \
              -H "Content-Type: application/json" \
              "${JIRA_BASE_URL}/rest/api/3/issue/$issue/comment" \
              -d "$payload")

            if [[ "$code2" -ge 400 ]]; then
              echo "Jira comment failed HTTP $code2"
              cat "$resp2"
              exit 1
            fi
          else
            echo "Creating new issue..."

            payload=$(python3 - <<'PY'
          import json, os
          payload={
            "fields":{
              "project":{"key":os.environ["JIRA_PROJECT_KEY"]},
              "issuetype":{"name":os.environ["JIRA_ISSUE_TYPE"]},
              "summary":f"[CI] Test failures on main @ {os.environ['COMMIT_SHA'][:7]}",
              "labels":[f"gha-{os.environ['COMMIT_SHA']}", "ci", "automated"],
              "description":{
                "type":"doc","version":1,
                "content":[{"type":"paragraph","content":[{"type":"text","text":os.environ["DESC"]}]}]
              }
            }
          }
          print(json.dumps(payload))
          PY
          )

            resp3=$(mktemp)
            code3=$(curl -sS -o "$resp3" -w "%{http_code}" -X POST \
              -u "${JIRA_EMAIL}:${JIRA_API_TOKEN}" \
              -H "Accept: application/json" \
              -H "Content-Type: application/json" \
              "${JIRA_BASE_URL}/rest/api/3/issue" \
              -d "$payload")

            if [[ "$code3" -ge 400 ]]; then
              echo "Jira create issue failed HTTP $code3"
              cat "$resp3"
              exit 1
            fi

            issue=$(python3 - "$resp3" <<'PY'
          import json,sys
          data=json.load(open(sys.argv[1]))
          print(data["key"])
          PY
          )
          fi

          echo "issue=$issue" >> $GITHUB_OUTPUT

      - name: Attach reports + logs to JIRA issue
        if: steps.gate.outputs.create == 'true' && github.ref == 'refs/heads/main'
        env:
          JIRA_BASE_URL: ${{ secrets.JIRA_BASE_URL }}
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_API_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          ISSUE_KEY: ${{ steps.jira.outputs.issue }}
        run: |
          set -euo pipefail

          JIRA_BASE_URL="$(printf "%s" "$JIRA_BASE_URL" | tr -d '\r\n' | sed 's:/*$::')"

          if [[ -z "${ISSUE_KEY:-}" ]]; then
            echo "No ISSUE_KEY produced; skipping attachment."
            exit 0
          fi

          if [[ ! -f jira-attachments.zip ]]; then
            echo "No jira-attachments.zip found; skipping attachment."
            exit 0
          fi

          resp=$(mktemp)
          code=$(curl -sS -o "$resp" -w "%{http_code}" -X POST \
            -u "${JIRA_EMAIL}:${JIRA_API_TOKEN}" \
            -H "X-Atlassian-Token: no-check" \
            -H "Accept: application/json" \
            -F "file=@jira-attachments.zip" \
            "${JIRA_BASE_URL}/rest/api/3/issue/${ISSUE_KEY}/attachments")

          if [[ "$code" -ge 400 ]]; then
            echo "Jira attach failed HTTP $code"
            cat "$resp"
            exit 1
          fi

          echo "Attached jira-attachments.zip to ${ISSUE_KEY}"
